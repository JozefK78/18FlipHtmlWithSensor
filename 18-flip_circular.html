<!--
Copyright 2022 Matthias Müller - Ten Minute Physics, 
www.youtube.com/c/TenMinutePhysics
www.matthiasMueller.info/tenMinutePhysics

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->

<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<head>
	<title>FLIP Fluid</title>
	<style>
		body {
			font-family: verdana;
			font-size: 15px;
		}

		.button {
			background-color: #606060;
			border: none;
			color: white;
			padding: 10px 10px;
			font-size: 16px;
			margin: 4px 2px;
			cursor: pointer;
		}

		.slider {
			-webkit-appearance: none;
			width: 80px;
			height: 6px;
			border-radius: 5px;
			background: #d3d3d3;
			outline: none;
			opacity: 0.7;
			-webkit-transition: .2s;
			transition: opacity .2s;
		}
	</style>
</head>

<!-- ... (previous HTML head and style) ... -->

<body>

	<!-- Add a button for iOS permissions -->
	<button id="permissionButton" class="button" style="display: none;">Enable Motion Controls</button><br>

	<input type="checkbox" checked onclick="scene.showParticles = !scene.showParticles">Particles  
	<input type="checkbox" onclick="scene.showGrid = !scene.showGrid">Grid  
	<input type="checkbox" checked onclick="scene.compensateDrift = !scene.compensateDrift">Compensate Drift  
	<input type="checkbox" checked onclick="scene.separateParticles = !scene.separateParticles">Separate Particles  
	PIC
	<input type="range" min="0" max="10" value="9" class="slider" onchange="scene.flipRatio = 0.1 * this.value"> FLIP
	<br>
	<canvas id="myCanvas" style="border:2px solid"></canvas>

	<script>

		var canvas = document.getElementById("myCanvas");
		var gl = canvas.getContext("webgl");
		canvas.width = window.innerWidth - 20;
		canvas.height = window.innerHeight - 20;

		canvas.focus();

		var simHeight = 3.0;
		var cScale = canvas.height / simHeight;
		var simWidth = canvas.width / cScale;

		var U_FIELD = 0;
		var V_FIELD = 1;

		var FLUID_CELL = 0;
		var AIR_CELL = 1;
		var SOLID_CELL = 2;
		var TIME_CELL = 3; // New cell type for clock digits
		
		var cnt = 0;
		
		function clamp(x, min, max) {
			if (x < min)
				return min;
			else if (x > max)
				return max;
			else
				return x;
		}
function isCellStaticWall(ix, iy, fluidObj, sceneObj) {
    // Check bounds first: cells outside the defined fNumX/fNumY grid are effectively solid walls
    if (ix < 0 || ix >= fluidObj.fNumX || iy < 0 || iy >= fluidObj.fNumY) return true;

    // Check if it's a time cell
    var N = fluidObj.fNumY; // Assuming fNumY is accessible as N or fluidObj.fNumY
    if (fluidObj.cellType[ix * N + iy] === TIME_CELL) return true;

    var cellRealX = (ix + 0.5) * fluidObj.h;
    var cellRealY = (iy + 0.5) * fluidObj.h;
    var distSqToMainCenter = (cellRealX - sceneObj.circleCenterX) * (cellRealX - sceneObj.circleCenterX) +
                             (cellRealY - sceneObj.circleCenterY) * (cellRealY - sceneObj.circleCenterY);
    // A cell is part of the static wall if its center is outside the main circle radius
    return distSqToMainCenter > (sceneObj.circleRadius * sceneObj.circleRadius);
}

function isCellDraggable(ix, iy, fluidObj, sceneObj) {
    if (!sceneObj.showObstacle) return false; // Draggable obstacle not active
    // Check bounds: draggable obstacle can only exist within the grid
    if (ix < 0 || ix >= fluidObj.fNumX || iy < 0 || iy >= fluidObj.fNumY) return false;

    var cellRealX = (ix + 0.5) * fluidObj.h;
    var cellRealY = (iy + 0.5) * fluidObj.h;
    var dxDraggable = cellRealX - sceneObj.obstacleX;
    var dyDraggable = cellRealY - sceneObj.obstacleY;
    // A cell is part of the draggable obstacle if its center is within the draggable obstacle's radius
    return (dxDraggable * dxDraggable + dyDraggable * dyDraggable) < (sceneObj.obstacleRadius * sceneObj.obstacleRadius);
}

		// ----------------- start of simulator ------------------------------

		class FlipFluid {
			constructor(density, width, height, spacing, particleRadius, maxParticles) {

				// ... (rest of constructor is unchanged) ...
				this.density = density;
				this.fNumX = Math.floor(width / spacing) + 1;
				this.fNumY = Math.floor(height / spacing) + 1;
				this.h = Math.max(width / this.fNumX, height / this.fNumY);
				this.fInvSpacing = 1.0 / this.h;
				this.fNumCells = this.fNumX * this.fNumY;

				this.u = new Float32Array(this.fNumCells);
				this.v = new Float32Array(this.fNumCells);
				this.du = new Float32Array(this.fNumCells);
				this.dv = new Float32Array(this.fNumCells);
				this.prevU = new Float32Array(this.fNumCells);
				this.prevV = new Float32Array(this.fNumCells);
				this.p = new Float32Array(this.fNumCells);
				this.s = new Float32Array(this.fNumCells);
				this.cellType = new Int32Array(this.fNumCells);
				this.cellColor = new Float32Array(3 * this.fNumCells);

				// particles

				this.maxParticles = maxParticles;

				this.particlePos = new Float32Array(2 * this.maxParticles);
				this.particleColor = new Float32Array(3 * this.maxParticles);
				for (var i = 0; i < this.maxParticles; i++)
					this.particleColor[3 * i + 2] = 1.0;

				this.particleVel = new Float32Array(2 * this.maxParticles);
				this.particleDensity = new Float32Array(this.fNumCells);
				this.particleRestDensity = 0.0;

				this.particleRadius = particleRadius;
				this.pInvSpacing = 1.0 / (2.2 * particleRadius);
				this.pNumX = Math.floor(width * this.pInvSpacing) + 1;
				this.pNumY = Math.floor(height * this.pInvSpacing) + 1;
				this.pNumCells = this.pNumX * this.pNumY;

				this.numCellParticles = new Int32Array(this.pNumCells);
				this.firstCellParticle = new Int32Array(this.pNumCells + 1);
				this.cellParticleIds = new Int32Array(maxParticles);

				this.numParticles = 0;
			}

			// *** MODIFIED integrateParticles ***
			integrateParticles(dt, gravityX, gravityY) // Accept Gx and Gy
			{
				for (var i = 0; i < this.numParticles; i++) {
					// Apply gravity components
					this.particleVel[2 * i] += dt * gravityX;
					this.particleVel[2 * i + 1] += dt * gravityY;

					// Update position
					this.particlePos[2 * i] += this.particleVel[2 * i] * dt;
					this.particlePos[2 * i + 1] += this.particleVel[2 * i + 1] * dt;
				}
			}

			// ... (pushParticlesApart is unchanged) ...
			pushParticlesApart(numIters) {
				var colorDiffusionCoeff = 0.001;

				// count particles per cell

				this.numCellParticles.fill(0);

				for (var i = 0; i < this.numParticles; i++) {
					var x = this.particlePos[2 * i];
					var y = this.particlePos[2 * i + 1];

					var xi = clamp(Math.floor(x * this.pInvSpacing), 0, this.pNumX - 1);
					var yi = clamp(Math.floor(y * this.pInvSpacing), 0, this.pNumY - 1);
					var cellNr = xi * this.pNumY + yi;
					this.numCellParticles[cellNr]++;
				}

				// partial sums

				var first = 0;

				for (var i = 0; i < this.pNumCells; i++) {
					first += this.numCellParticles[i];
					this.firstCellParticle[i] = first;
				}
				this.firstCellParticle[this.pNumCells] = first;		// guard

				// fill particles into cells

				for (var i = 0; i < this.numParticles; i++) {
					var x = this.particlePos[2 * i];
					var y = this.particlePos[2 * i + 1];

					var xi = clamp(Math.floor(x * this.pInvSpacing), 0, this.pNumX - 1);
					var yi = clamp(Math.floor(y * this.pInvSpacing), 0, this.pNumY - 1);
					var cellNr = xi * this.pNumY + yi;
					this.firstCellParticle[cellNr]--;
					this.cellParticleIds[this.firstCellParticle[cellNr]] = i;
				}

				// push particles apart

				var minDist = 2.0 * this.particleRadius;
				var minDist2 = minDist * minDist;

				for (var iter = 0; iter < numIters; iter++) {

					for (var i = 0; i < this.numParticles; i++) {
						var px = this.particlePos[2 * i];
						var py = this.particlePos[2 * i + 1];

						var pxi = Math.floor(px * this.pInvSpacing);
						var pyi = Math.floor(py * this.pInvSpacing);
						var x0 = Math.max(pxi - 1, 0);
						var y0 = Math.max(pyi - 1, 0);
						var x1 = Math.min(pxi + 1, this.pNumX - 1);
						var y1 = Math.min(pyi + 1, this.pNumY - 1);

						for (var xi = x0; xi <= x1; xi++) {
							for (var yi = y0; yi <= y1; yi++) {
								var cellNr = xi * this.pNumY + yi;
								var first = this.firstCellParticle[cellNr];
								var last = this.firstCellParticle[cellNr + 1];
								for (var j = first; j < last; j++) {
									var id = this.cellParticleIds[j];
									if (id == i)
										continue;
									var qx = this.particlePos[2 * id];
									var qy = this.particlePos[2 * id + 1];

									var dx = qx - px;
									var dy = qy - py;
									var d2 = dx * dx + dy * dy;
									if (d2 > minDist2 || d2 == 0.0)
										continue;
									var d = Math.sqrt(d2);
									var s = 0.5 * (minDist - d) / d;
									dx *= s;
									dy *= s;
									this.particlePos[2 * i] -= dx;
									this.particlePos[2 * i + 1] -= dy;
									this.particlePos[2 * id] += dx;
									this.particlePos[2 * id + 1] += dy;

									// diffuse colors

									for (var k = 0; k < 3; k++) {
										var color0 = this.particleColor[3 * i + k];
										var color1 = this.particleColor[3 * id + k];
										var color = (color0 + color1) * 0.5;
										this.particleColor[3 * i + k] = color0 + (color - color0) * colorDiffusionCoeff;
										this.particleColor[3 * id + k] = color1 + (color - color1) * colorDiffusionCoeff;
									}
								}
							}
						}
					}
				}
			}

			// File: 18-flip-circle.html

			handleParticleCollisions(obstacleX, obstacleY, obstacleRadiusDraggable) {
				var rParticle = this.particleRadius;

				// Draggable Obstacle properties (if active)
				var orDraggable = obstacleRadiusDraggable;
				var minDistDraggable = orDraggable + rParticle;
				var minDistDraggable2 = minDistDraggable * minDistDraggable;

				// Main Circular Wall properties
				var mainCircleX = scene.circleCenterX;
				var mainCircleY = scene.circleCenterY;
				var mainCircleR = scene.circleRadius;
				// Effective radius for particle *centers* for the main wall collision
				var wallCollisionRadius = mainCircleR - rParticle;

				for (var i = 0; i < this.numParticles; i++) {
					var x = this.particlePos[2 * i];
					var y = this.particlePos[2 * i + 1];
					var vx = this.particleVel[2 * i]; // Current particle velocity x
					var vy = this.particleVel[2 * i + 1]; // Current particle velocity y

					// 1. Draggable obstacle collision (if active and shown)
					if (scene.showObstacle) {
						var dxObs = x - obstacleX; // obstacleX, Y are center of draggable obstacle
						var dyObs = y - obstacleY;
						var d2Obs = dxObs * dxObs + dyObs * dyObs;

						if (d2Obs < minDistDraggable2 && d2Obs > 1e-9) { // Check d2Obs > epsilon to avoid issues if particle is at center
							var dObs = Math.sqrt(d2Obs);
							// Positional correction: push particle out
							var overlap = minDistDraggable - dObs;
							var pushRatio = overlap / dObs; // s in the original paper for particle-obstacle
							x += dxObs * pushRatio;
							y += dyObs * pushRatio;

							// Velocity response: assign obstacle velocity (original JS behavior for obstacle)
							vx = scene.obstacleVelX;
							vy = scene.obstacleVelY;
						}
					}

					// 2. Main Circular Wall collision
					var dxWall = x - mainCircleX;
					var dyWall = y - mainCircleY;
					var distSqToWallCenter = dxWall * dxWall + dyWall * dyWall;

					if (distSqToWallCenter > wallCollisionRadius * wallCollisionRadius && distSqToWallCenter > 1e-9) {
						var distToWallCenter = Math.sqrt(distSqToWallCenter);

						// Positional correction: push particle back inside
						var overlapWall = distToWallCenter - wallCollisionRadius;
						x -= (dxWall / distToWallCenter) * overlapWall;
						y -= (dyWall / distToWallCenter) * overlapWall;

						// Velocity response: Zero velocity (matches original rectangular wall behavior)
						vx = 0.0;
						vy = 0.0;
					}

					// Update particle state
					this.particlePos[2 * i] = x;
					this.particlePos[2 * i + 1] = y;
					this.particleVel[2 * i] = vx;
					this.particleVel[2 * i + 1] = vy;
				}
			}	// ... (updateParticleDensity is unchanged) ...
			updateParticleDensity() {
				var n = this.fNumY;
				var h = this.h;
				var h1 = this.fInvSpacing;
				var h2 = 0.5 * h;

				var d = f.particleDensity;

				d.fill(0.0);

				for (var i = 0; i < this.numParticles; i++) {
					var x = this.particlePos[2 * i];
					var y = this.particlePos[2 * i + 1];

					x = clamp(x, h, (this.fNumX - 1) * h);
					y = clamp(y, h, (this.fNumY - 1) * h);

					var x0 = Math.floor((x - h2) * h1);
					var tx = ((x - h2) - x0 * h) * h1;
					var x1 = Math.min(x0 + 1, this.fNumX - 2);

					var y0 = Math.floor((y - h2) * h1);
					var ty = ((y - h2) - y0 * h) * h1;
					var y1 = Math.min(y0 + 1, this.fNumY - 2);

					var sx = 1.0 - tx;
					var sy = 1.0 - ty;

					if (x0 < this.fNumX && y0 < this.fNumY) d[x0 * n + y0] += sx * sy;
					if (x1 < this.fNumX && y0 < this.fNumY) d[x1 * n + y0] += tx * sy;
					if (x1 < this.fNumX && y1 < this.fNumY) d[x1 * n + y1] += tx * ty;
					if (x0 < this.fNumX && y1 < this.fNumY) d[x0 * n + y1] += sx * ty;
				}

				if (this.particleRestDensity == 0.0) {
					var sum = 0.0;
					var numFluidCells = 0;

					for (var i = 0; i < this.fNumCells; i++) {
						if (this.cellType[i] == FLUID_CELL) {
							sum += d[i];
							numFluidCells++;
						}
					}

					if (numFluidCells > 0)
						this.particleRestDensity = sum / numFluidCells;
				}

			}

			// ... (transferVelocities is unchanged) ...
			transferVelocities(toGrid, flipRatio) {
				var n = this.fNumY;
				var h = this.h;
				var h1 = this.fInvSpacing;
				var h2 = 0.5 * h;

				if (toGrid) {

					this.prevU.set(this.u);
					this.prevV.set(this.v);

					this.du.fill(0.0);
					this.dv.fill(0.0);
					this.u.fill(0.0);
					this.v.fill(0.0);

					for (var i = 0; i < this.fNumCells; i++) {
					                   if (this.cellType[i] == TIME_CELL) { // Preserve TIME_CELL
					                       this.s[i] = 0.0; // Ensure it's solid for solver
					                       continue;
					                   }
					                   this.cellType[i] = this.s[i] == 0.0 ? SOLID_CELL : AIR_CELL;
					               }

					for (var i = 0; i < this.numParticles; i++) {
						var x = this.particlePos[2 * i];
						var y = this.particlePos[2 * i + 1];
						var xi = clamp(Math.floor(x * h1), 0, this.fNumX - 1);
						var yi = clamp(Math.floor(y * h1), 0, this.fNumY - 1);
						var cellNr = xi * n + yi;
						if (this.cellType[cellNr] == AIR_CELL) // Only change AIR_CELL to FLUID_CELL
							this.cellType[cellNr] = FLUID_CELL;
					}
				}

				for (var component = 0; component < 2; component++) {

					var dx = component == 0 ? 0.0 : h2;
					var dy = component == 0 ? h2 : 0.0;

					var f = component == 0 ? this.u : this.v;
					var prevF = component == 0 ? this.prevU : this.prevV;
					var d = component == 0 ? this.du : this.dv;

					for (var i = 0; i < this.numParticles; i++) {
						var x = this.particlePos[2 * i];
						var y = this.particlePos[2 * i + 1];

						x = clamp(x, h, (this.fNumX - 1) * h);
						y = clamp(y, h, (this.fNumY - 1) * h);

						var x0 = Math.min(Math.floor((x - dx) * h1), this.fNumX - 2);
						var tx = ((x - dx) - x0 * h) * h1;
						var x1 = Math.min(x0 + 1, this.fNumX - 2);

						var y0 = Math.min(Math.floor((y - dy) * h1), this.fNumY - 2);
						var ty = ((y - dy) - y0 * h) * h1;
						var y1 = Math.min(y0 + 1, this.fNumY - 2);

						var sx = 1.0 - tx;
						var sy = 1.0 - ty;

						var d0 = sx * sy;
						var d1 = tx * sy;
						var d2 = tx * ty;
						var d3 = sx * ty;

						var nr0 = x0 * n + y0;
						var nr1 = x1 * n + y0;
						var nr2 = x1 * n + y1;
						var nr3 = x0 * n + y1;

						if (toGrid) {
							var pv = this.particleVel[2 * i + component];
							f[nr0] += pv * d0; d[nr0] += d0;
							f[nr1] += pv * d1; d[nr1] += d1;
							f[nr2] += pv * d2; d[nr2] += d2;
							f[nr3] += pv * d3; d[nr3] += d3;
						}
						else {
							var offset = component == 0 ? n : 1;
							var valid0 = this.cellType[nr0] != AIR_CELL || this.cellType[nr0 - offset] != AIR_CELL ? 1.0 : 0.0;
							var valid1 = this.cellType[nr1] != AIR_CELL || this.cellType[nr1 - offset] != AIR_CELL ? 1.0 : 0.0;
							var valid2 = this.cellType[nr2] != AIR_CELL || this.cellType[nr2 - offset] != AIR_CELL ? 1.0 : 0.0;
							var valid3 = this.cellType[nr3] != AIR_CELL || this.cellType[nr3 - offset] != AIR_CELL ? 1.0 : 0.0;

							var v = this.particleVel[2 * i + component];
							var d = valid0 * d0 + valid1 * d1 + valid2 * d2 + valid3 * d3;

							if (d > 0.0) {

								var picV = (valid0 * d0 * f[nr0] + valid1 * d1 * f[nr1] + valid2 * d2 * f[nr2] + valid3 * d3 * f[nr3]) / d;
								var corr = (valid0 * d0 * (f[nr0] - prevF[nr0]) + valid1 * d1 * (f[nr1] - prevF[nr1])
									+ valid2 * d2 * (f[nr2] - prevF[nr2]) + valid3 * d3 * (f[nr3] - prevF[nr3])) / d;
								var flipV = v + corr;

								this.particleVel[2 * i + component] = (1.0 - flipRatio) * picV + flipRatio * flipV;
							}
						}
					}

					if (toGrid) {
						for (var i = 0; i < f.length; i++) {
							if (d[i] > 0.0)
								f[i] /= d[i];
						}

						// restore solid cells

						for (var i = 0; i < this.fNumX; i++) {
							for (var j = 0; j < this.fNumY; j++) {
								var solid = this.cellType[i * n + j] == SOLID_CELL;
								if (solid || (i > 0 && this.cellType[(i - 1) * n + j] == SOLID_CELL))
									this.u[i * n + j] = this.prevU[i * n + j];
								if (solid || (j > 0 && this.cellType[i * n + j - 1] == SOLID_CELL))
									this.v[i * n + j] = this.prevV[i * n + j];
							}
						}
					}
				}
			}

			// ... (solveIncompressibility is unchanged) ...
			solveIncompressibility(numIters, dt, overRelaxation, compensateDrift = true) {

				this.p.fill(0.0);
				this.prevU.set(this.u); // Store u before pressure solve (used by G2P)
				this.prevV.set(this.v); // Store v before pressure solve (used by G2P)

				var n = this.fNumY;
				var cp = this.density * this.h / dt;

				for (var iter = 0; iter < numIters; iter++) {
					for (var i = 1; i < this.fNumX - 1; i++) {
						for (var j = 1; j < this.fNumY - 1; j++) {

							if (this.cellType[i*n + j] != FLUID_CELL)
								continue;

							var center = i * n + j;
							var left = (i - 1) * n + j;
							var right = (i + 1) * n + j;
							var bottom = i * n + j - 1;
							var top = i * n + j + 1;

			                     // s values are based on cell (i,j)'s neighbors being fluid (1) or solid (0)
						var sx0 = this.s[left];  // s of cell to the left of cell (i,j)
						var sx1 = this.s[right]; // s of cell to the right of cell (i,j)
						var sy0 = this.s[bottom];// s of cell below cell (i,j)
						var sy1 = this.s[top];   // s of cell above cell (i,j)

			                     var sum_s = sx0 + sx1 + sy0 + sy1;
						if (sum_s == 0.0)
							continue;

			                     // Divergence uses u[right] (u component on right face of cell i,j)
			                     // and u[center] (u component on left face of cell i,j)
						var div = this.u[right] - this.u[center] +
							      this.v[top] - this.v[center]; // Similar for v

						if (this.particleRestDensity > 0.0 && compensateDrift) {
							var k = 1.0; // Relaxation factor for density correction
							var compression = this.particleDensity[i*n + j] - this.particleRestDensity;
							if (compression > 0.0) // Only act on compression, not expansion
								div = div - k * compression; // Adjust divergence to counteract compression
						}

						var p_iter = -div / sum_s;
						p_iter *= overRelaxation;
						this.p[center] += cp * p_iter; // Accumulate pressure correction

			                     // Apply pressure correction to velocities
						this.u[center] -= sx0 * p_iter;
						this.u[right]  += sx1 * p_iter;
						this.v[center] -= sy0 * p_iter;
						this.v[top]    += sy1 * p_iter;
					}
				}
			}

			         // --- BEGIN NEW: Re-enforce boundary conditions on u and v after pressure solve ---
			         var currentScene = window.scene; // Access the global scene object

			         // Enforce u-velocities: u[idx = i*n+j] is velocity on the LEFT face of cell (i,j).
			         // It is horizontally between cell (i-1,j) and cell (i,j).
			         for (var i = 0; i < this.fNumX; i++) { // Loop over grid cell columns
			             for (var j = 0; j < this.fNumY; j++) { // Loop over grid cell rows
			                 var u_idx = i * n + j;

			                 // Check cells adjacent to this u-velocity face: (i-1,j) and (i,j)
			                 var leftCellStatic = (i === 0) || isCellStaticWall(i - 1, j, this, currentScene);
			                 var rightCellStatic = isCellStaticWall(i, j, this, currentScene);

			                 var leftCellDraggable = (i > 0) && isCellDraggable(i - 1, j, this, currentScene);
			                 var rightCellDraggable = isCellDraggable(i, j, this, currentScene);

			                 if (leftCellStatic || rightCellStatic) {
			                     this.u[u_idx] = 0.0;
			                 } else if (leftCellDraggable || rightCellDraggable) {
			                     // If either adjacent cell is draggable (and not overridden by static wall),
			                     // set u-velocity to draggable obstacle's x-velocity.
			                     this.u[u_idx] = currentScene.obstacleVelX;
			                 }

			                 // Enforce v-velocities: v[idx = i*n+j] is velocity on the BOTTOM face of cell (i,j).
			                 // It is vertically between cell (i,j-1) and cell (i,j).
			                 var v_idx = i * n + j;

			                 // Check cells adjacent to this v-velocity face: (i,j-1) and (i,j)
			                 var bottomCellStatic = (j === 0) || isCellStaticWall(i, j - 1, this, currentScene);
			                 var topCellStatic = isCellStaticWall(i, j, this, currentScene);

			                 var bottomCellDraggable = (j > 0) && isCellDraggable(i, j - 1, this, currentScene);
			                 var topCellDraggable = isCellDraggable(i, j, this, currentScene);

			                 if (bottomCellStatic || topCellStatic) {
			                     this.v[v_idx] = 0.0;
			                 } else if (bottomCellDraggable || topCellDraggable) {
			                     // If either adjacent cell is draggable (and not overridden by static wall),
			                     // set v-velocity to draggable obstacle's y-velocity.
			                     this.v[v_idx] = currentScene.obstacleVelY;
			                 }
			             }
			         }
			         // --- END NEW ---
		}

			// ... (updateParticleColors is unchanged) ...
			updateParticleColors() {
				// ... (content unchanged) ...
				var h1 = this.fInvSpacing;

				for (var i = 0; i < this.numParticles; i++) {

					var s = 0.01;

					this.particleColor[3 * i] = clamp(this.particleColor[3 * i] - s, 0.0, 1.0);
					this.particleColor[3 * i + 1] = clamp(this.particleColor[3 * i + 1] - s, 0.0, 1.0);
					this.particleColor[3 * i + 2] = clamp(this.particleColor[3 * i + 2] + s, 0.0, 1.0);

					var x = this.particlePos[2 * i];
					var y = this.particlePos[2 * i + 1];
					var xi = clamp(Math.floor(x * h1), 1, this.fNumX - 1);
					var yi = clamp(Math.floor(y * h1), 1, this.fNumY - 1);
					var cellNr = xi * this.fNumY + yi;

					var d0 = this.particleRestDensity;

					if (d0 > 0.0) {
						var relDensity = this.particleDensity[cellNr] / d0;
						if (relDensity < 0.7) {
							var s = 0.8;
							this.particleColor[3 * i] = s;
							this.particleColor[3 * i + 1] = s;
							this.particleColor[3 * i + 2] = 1.0;
						}
					}
				}
			}

			// ... (setSciColor is unchanged) ...
			setSciColor(cellNr, val, minVal, maxVal) {
				val = Math.min(Math.max(val, minVal), maxVal - 0.0001);
				var d = maxVal - minVal;
				val = d == 0.0 ? 0.5 : (val - minVal) / d;
				var m = 0.25;
				var num = Math.floor(val / m);
				var s = (val - num * m) / m;
				var r, g, b;

				switch (num) {
					case 0: r = 0.0; g = s; b = 1.0; break;
					case 1: r = 0.0; g = 1.0; b = 1.0 - s; break;
					case 2: r = s; g = 1.0; b = 0.0; break;
					case 3: r = 1.0; g = 1.0 - s; b = 0.0; break;
				}

				this.cellColor[3 * cellNr] = r;
				this.cellColor[3 * cellNr + 1] = g;
				this.cellColor[3 * cellNr + 2] = b;
			}


			// ... (updateCellColors is unchanged) ...
			updateCellColors() {
				this.cellColor.fill(0.0);

				for (var i = 0; i < this.fNumCells; i++) {

					if (this.cellType[i] == SOLID_CELL) {
						this.cellColor[3 * i] = 0.5;
						this.cellColor[3 * i + 1] = 0.5;
						this.cellColor[3 * i + 2] = 0.5;
					}
						              else if (this.cellType[i] == TIME_CELL) {
						                  this.cellColor[3 * i] = 0.9; // Light gray for time cells
						                  this.cellColor[3 * i + 1] = 0.9;
						                  this.cellColor[3 * i + 2] = 0.9;
						              }
					else if (this.cellType[i] == FLUID_CELL) {
						var d = this.particleDensity[i];
						if (this.particleRestDensity > 0.0)
							d /= this.particleRestDensity;
						this.setSciColor(i, d, 0.0, 2.0);
					}
				}
			}


			// *** MODIFIED simulate ***
			simulate(dt, gravityX, gravityY, flipRatio, numPressureIters, numParticleIters, overRelaxation, compensateDrift, separateParticles, obstacleX, abstacleY, obstacleRadius) // Accept Gx and Gy
			{
				var numSubSteps = 1;
				var sdt = dt / numSubSteps;

				for (var step = 0; step < numSubSteps; step++) {
					this.integrateParticles(sdt, gravityX, gravityY); // Pass Gx and Gy
					if (separateParticles)
						this.pushParticlesApart(numParticleIters);
					this.handleParticleCollisions(obstacleX, abstacleY, obstacleRadius)
					this.transferVelocities(true, flipRatio); // Pass flipRatio here too
					this.updateParticleDensity();
					this.solveIncompressibility(numPressureIters, sdt, overRelaxation, compensateDrift);
					this.transferVelocities(false, flipRatio);
				}

				this.updateParticleColors();
				this.updateCellColors();
			}
		}

		// ----------------- end of simulator ------------------------------

		// *** MODIFIED scene object ***
		var scene =
		{
			// gravity : -9.81, // Removed
			gravityX: 0.0,      // Added
			gravityY: -9.81,    // Added (default down)
			dt: 1.0 / 120.0,    // Faster dt for potentially faster sensor updates
			flipRatio: 0.9,
			numPressureIters: 100,
			numParticleIters: 2,
			frameNr: 0,
			overRelaxation: 1.9,
			compensateDrift: true,
			separateParticles: true,
			obstacleX: 0.0,
			obstacleY: 0.0,
			obstacleRadius: 0.15,
			paused: false, // Start running by default if sensors are enabled
			showObstacle: true,
			obstacleVelX: 0.0,
			obstacleVelY: 0.0,
			showParticles: true,
			showGrid: false,
			         clockDigitsData: {},
			         timeCellCoords: [], // Stores [i,j] of current time cells
			         clockConfig: {
			             digitWidth: 3,
			             digitHeight: 5,
			             colonWidth: 1, // Width for the colon
			             spacing: 1,    // Spacing between characters
			             offsetX: 0,    // Calculated based on grid size
			             offsetY: 0     // Calculated based on grid size
			         },
			         lastMinuteDisplayed: -1,
			fluid: null
		};


			     function initClockDigitsData() {
			         // 3x5 pixel art for digits 0-9, 1 for ON, 0 for OFF
			         // Each array is a row
			         scene.clockDigitsData['0'] = [
			             [1, 1, 1],
			             [1, 0, 1],
			             [1, 0, 1],
			             [1, 0, 1],
			             [1, 1, 1]
			         ];
			         scene.clockDigitsData['1'] = [
			             [0, 1, 0],
			             [1, 1, 0],
			             [0, 1, 0],
			             [0, 1, 0],
			             [1, 1, 1]
			         ];
			         scene.clockDigitsData['2'] = [
			             [1, 1, 1],
			             [0, 0, 1],
			             [1, 1, 1],
			             [1, 0, 0],
			             [1, 1, 1]
			         ];
			         scene.clockDigitsData['3'] = [
			             [1, 1, 1],
			             [0, 0, 1],
			             [0, 1, 1],
			             [0, 0, 1],
			             [1, 1, 1]
			         ];
			         scene.clockDigitsData['4'] = [
			             [1, 0, 1],
			             [1, 0, 1],
			             [1, 1, 1],
			             [0, 0, 1],
			             [0, 0, 1]
			         ];
			         scene.clockDigitsData['5'] = [
			             [1, 1, 1],
			             [1, 0, 0],
			             [1, 1, 1],
			             [0, 0, 1],
			             [1, 1, 1]
			         ];
			         scene.clockDigitsData['6'] = [
			             [1, 1, 1],
			             [1, 0, 0],
			             [1, 1, 1],
			             [1, 0, 1],
			             [1, 1, 1]
			         ];
			         scene.clockDigitsData['7'] = [
			             [1, 1, 1],
			             [0, 0, 1],
			             [0, 1, 0],
			             [0, 1, 0],
			             [0, 1, 0]
			         ];
			         scene.clockDigitsData['8'] = [
			             [1, 1, 1],
			             [1, 0, 1],
			             [1, 1, 1],
			             [1, 0, 1],
			             [1, 1, 1]
			         ];
			         scene.clockDigitsData['9'] = [
			             [1, 1, 1],
			             [1, 0, 1],
			             [1, 1, 1],
			             [0, 0, 1],
			             [1, 1, 1]
			         ];
			         scene.clockDigitsData[':'] = [ // 1x5 for colon
			             [0],
			             [1],
			             [0],
			             [1],
			             [0]
			         ];
			     }

			     function updateTimeDisplayOnGrid() {
			         if (!scene.fluid) return;
			         var f = scene.fluid;
			         var n = f.fNumY;

			         // 1. Clear previous time cells
			         for (const cell of scene.timeCellCoords) {
			             var ix = cell[0];
			             var iy = cell[1];
			             if (ix >= 0 && ix < f.fNumX && iy >= 0 && iy < f.fNumY) {
			                 var idx = ix * n + iy;
			                 // Revert to AIR_CELL, s=1.0. transferVelocities will handle if it becomes FLUID_CELL.
			                 // Check if it's not part of the main circular boundary first
			                 var cellRealX = (ix + 0.5) * f.h;
			                 var cellRealY = (iy + 0.5) * f.h;
			                 var distSqToMainCenter = (cellRealX - scene.circleCenterX) * (cellRealX - scene.circleCenterX) +
			                                          (cellRealY - scene.circleCenterY) * (cellRealY - scene.circleCenterY);
			                 if (distSqToMainCenter <= scene.circleRadius * scene.circleRadius) { // Only clear if inside circle
			                     f.cellType[idx] = AIR_CELL;
			                     f.s[idx] = 1.0;
			                 }
			             }
			         }
			         scene.timeCellCoords = [];

			         // 2. Get current time and format
			         var now = new Date();
			         var hours = now.getHours();
			         var minutes = now.getMinutes();
			         var timeString = String(hours).padStart(2, '0') + ":" + String(minutes).padStart(2, '0'); // HH:MM

			         // 3. Draw new time
			         var currentGridX = scene.clockConfig.offsetX;
			         var baseGridY = scene.clockConfig.offsetY;

			         for (var charIndex = 0; charIndex < timeString.length; charIndex++) {
			             var char = timeString[charIndex];
			             var digitPattern = scene.clockDigitsData[char];
			             if (!digitPattern) continue;

			             var charWidth = (char === ':') ? scene.clockConfig.colonWidth : scene.clockConfig.digitWidth;

			             for (var r = 0; r < scene.clockConfig.digitHeight; r++) { // Iterate pixel rows (0 to 4)
			                 for (var c = 0; c < charWidth; c++) { // Iterate pixel columns (0 to 2 or 0 for colon)
			                     if (digitPattern[r] && digitPattern[r][c] === 1) {
			                         var ix = currentGridX + c;
			                         var iy = baseGridY + r;

			                         if (ix >= 0 && ix < f.fNumX && iy >= 0 && iy < f.fNumY) {
			                             // Check if inside main circle before marking as TIME_CELL
			                             var cellRealX = (ix + 0.5) * f.h;
			                             var cellRealY = (iy + 0.5) * f.h;
			                             var distSqToMainCenter = (cellRealX - scene.circleCenterX) * (cellRealX - scene.circleCenterX) +
			                                                      (cellRealY - scene.circleCenterY) * (cellRealY - scene.circleCenterY);

			                             if (distSqToMainCenter <= (scene.circleRadius - f.h) * (scene.circleRadius - f.h)) { // Ensure slightly inside
			                                 var idx = ix * n + iy;
			                                 f.cellType[idx] = TIME_CELL;
			                                 f.s[idx] = 0.0; // Solid
			                                 scene.timeCellCoords.push([ix, iy]);
			                             }
			                         }
			                     }
			                 }
			             }
			             currentGridX += charWidth + scene.clockConfig.spacing;
			         }
			     }

		// File: 18-flip-circle.html

		function setupScene() {
			scene.obstacleRadius = 0.15; // This is for the draggable obstacle
			scene.overRelaxation = 1.9;

			scene.numPressureIters = 50;
			scene.numParticleIters = 2;

			var res = 100;

			var tankHeight = simHeight; // Use global simHeight
			var tankWidth = simWidth;   // Use global simWidth
			var h = tankHeight / res;   // Target grid cell spacing
			var density = 1000.0;

			// Define circular container properties
			var circleCenterX = tankWidth / 2.0;
			var circleCenterY = tankHeight / 2.0;
			// Radius is 40% of min dimension (diameter is 80%)
			var circleRadius = 0.4 * Math.min(tankWidth, tankHeight);

			// Store main circle parameters in the scene object for global access
			scene.circleCenterX = circleCenterX;
			scene.circleCenterY = circleCenterY;
			scene.circleRadius = circleRadius;

			// Particle properties
			var r = 0.3 * h;	// particle radius w.r.t. cell size
			var dx = 2.0 * r;   // Horizontal spacing for staggered particles
			var dy = Math.sqrt(3.0) / 2.0 * dx; // Vertical spacing for staggered particles

			var estNumX_circle = Math.floor((2 * circleRadius) / dx);
			var estNumY_circle = Math.floor((2 * circleRadius) / dy);
			var maxParticles = Math.max(1000, estNumX_circle * estNumY_circle * 2); // More generous maxParticles

			// Create fluid
			f = scene.fluid = new FlipFluid(density, tankWidth, tankHeight, h, r, maxParticles);
			// f.h is now the actual grid spacing used by the fluid sim

			         initClockDigitsData(); // Initialize digit patterns

			         // Calculate clock position (center it roughly)
			         var conf = scene.clockConfig;
			         var totalClockWidthCells = (conf.digitWidth + conf.spacing) * 4 + (conf.colonWidth + conf.spacing) * 1 - conf.spacing; // HH:MM
			         var totalClockHeightCells = conf.digitHeight;
			         scene.clockConfig.offsetX = Math.floor(f.fNumX / 2 - totalClockWidthCells / 2);
			         // Place it slightly above the vertical center
			         scene.clockConfig.offsetY = Math.floor(f.fNumY / 2 - totalClockHeightCells / 2 - 3); // Move up a bit


			// Create particles within the bottom third of the circular container
			f.numParticles = 0;
			var p_idx = 0; // Index for particlePos array (stores 2 floats per particle)

			// Define the fill region for particles (bottom 1/3 of the circle's height)
			// Particles placed slightly away from the absolute bottom edge
			var fillMinY = circleCenterY - circleRadius + f.particleRadius * 2.0;
			var fillMaxY = circleCenterY - circleRadius + (2.0 * circleRadius / 3.0) - f.particleRadius * 2.0;

			var particleCount = 0;
			for (var yCand = fillMinY; yCand < fillMaxY && particleCount < f.maxParticles; yCand += dy) {
				var isOddRow = (Math.floor((yCand - fillMinY) / dy) % 2) == 1;
				// Calculate available width at this yCand within the circle
				var halfWidthAtY = 0;
				var dyFromCenter = Math.abs(yCand - circleCenterY);
				if (dyFromCenter < circleRadius) {
					halfWidthAtY = Math.sqrt(circleRadius * circleRadius - dyFromCenter * dyFromCenter);
				}

				var startX = circleCenterX - halfWidthAtY + f.particleRadius * 2.0 + (isOddRow ? f.particleRadius : 0.0);
				var endX = circleCenterX + halfWidthAtY - f.particleRadius * 2.0;

				for (var xCand = startX; xCand < endX && particleCount < f.maxParticles; xCand += dx) {
					// Double check particle center is within the circle (it should be by construction of startX/endX)
					var distSq = (xCand - circleCenterX) * (xCand - circleCenterX) +
						(yCand - circleCenterY) * (yCand - circleCenterY);

					// Ensure particle is a bit away from the boundary
					if (distSq < (circleRadius - f.particleRadius * 1.5) * (circleRadius - f.particleRadius * 1.5)) {
						if (p_idx < 2 * f.maxParticles) {
							f.particlePos[p_idx++] = xCand;
							f.particlePos[p_idx++] = yCand;
							particleCount++;
						}
					}
				}
			}
			f.numParticles = particleCount;

			// Setup grid cells (s array) for the circular tank
			var n = f.fNumY;
			var mainCircleR2 = scene.circleRadius * scene.circleRadius; // Use squared radius for comparison

			for (var i = 0; i < f.fNumX; i++) {
				for (var j = 0; j < f.fNumY; j++) {
					var cellRealX = (i + 0.5) * f.h;
					var cellRealY = (j + 0.5) * f.h;

					var distSqToCenter = (cellRealX - scene.circleCenterX) * (cellRealX - scene.circleCenterX) +
						(cellRealY - scene.circleCenterY) * (cellRealY - scene.circleCenterY);

					if (distSqToCenter > mainCircleR2) {
						f.s[i * n + j] = 0.0;	// Solid (outside the main circle)
					} else {
						f.s[i * n + j] = 1.0;	// Fluid/Air (inside the main circle)
					}
				}
			}
						      updateTimeDisplayOnGrid(); // Initial time display

			// Set initial draggable obstacle position (e.g., center of the circle)
			// Pass true for reset, so its velocity is initially zero.
			setObstacle(scene.circleCenterX, scene.circleCenterY + scene.circleRadius * 0.2, true);
			scene.showObstacle = false; // Initially, draggable obstacle is not shown/active until drag
		}

		// draw -------------------------------------------------------
		// ... (drawing code is unchanged: pointVertexShader, pointFragmentShader, etc...) ...
		// ... (meshVertexShader, meshFragmentShader, createShader, draw function are unchanged) ...
		const pointVertexShader = `
		attribute vec2 attrPosition;
		attribute vec3 attrColor;
		uniform vec2 domainSize;
		uniform float pointSize;
		uniform float drawDisk;

		varying vec3 fragColor;
		varying float fragDrawDisk;

		void main() {
		vec4 screenTransform =
			vec4(2.0 / domainSize.x, 2.0 / domainSize.y, -1.0, -1.0);
		gl_Position =
			vec4(attrPosition * screenTransform.xy + screenTransform.zw, 0.0, 1.0);

		gl_PointSize = pointSize;
		fragColor = attrColor;
		fragDrawDisk = drawDisk;
		}
	`;

		const pointFragmentShader = `
		precision mediump float;
		varying vec3 fragColor;
		varying float fragDrawDisk;

		void main() {
			if (fragDrawDisk == 1.0) {
				float rx = 0.5 - gl_PointCoord.x;
				float ry = 0.5 - gl_PointCoord.y;
				float r2 = rx * rx + ry * ry;
				if (r2 > 0.25)
					discard;
			}
			gl_FragColor = vec4(fragColor, 1.0);
		}
	`;

		const meshVertexShader = `
		attribute vec2 attrPosition;
		uniform vec2 domainSize;
		uniform vec3 color;
		uniform vec2 translation;
		uniform float scale;

		varying vec3 fragColor;

		void main() {
			vec2 v = translation + attrPosition * scale;
		vec4 screenTransform =
			vec4(2.0 / domainSize.x, 2.0 / domainSize.y, -1.0, -1.0);
		gl_Position =
			vec4(v * screenTransform.xy + screenTransform.zw, 0.0, 1.0);

		fragColor = color;
		}
	`;

		const meshFragmentShader = `
		precision mediump float;
		varying vec3 fragColor;

		void main() {
			gl_FragColor = vec4(fragColor, 1.0);
		}
	`;

		function createShader(gl, vsSource, fsSource) {
			const vsShader = gl.createShader(gl.VERTEX_SHADER);
			gl.shaderSource(vsShader, vsSource);
			gl.compileShader(vsShader);
			if (!gl.getShaderParameter(vsShader, gl.COMPILE_STATUS))
				console.log("vertex shader compile error: " + gl.getShaderInfoLog(vsShader));

			const fsShader = gl.createShader(gl.FRAGMENT_SHADER);
			gl.shaderSource(fsShader, fsSource);
			gl.compileShader(fsShader);
			if (!gl.getShaderParameter(fsShader, gl.COMPILE_STATUS))
				console.log("fragment shader compile error: " + gl.getShaderInfoLog(fsShader));

			var shader = gl.createProgram();
			gl.attachShader(shader, vsShader);
			gl.attachShader(shader, fsShader);
			gl.linkProgram(shader);

			return shader;
		}

		var pointShader = null;
		var meshShader = null;

		var pointVertexBuffer = null;
		var pointColorBuffer = null;

		var gridVertBuffer = null;
		var gridColorBuffer = null;

		var diskVertBuffer = null;
		var diskIdBuffer = null;

		function draw() {
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.clear(gl.COLOR_BUFFER_BIT);

			gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

			// prepare shaders

			if (pointShader == null)
				pointShader = createShader(gl, pointVertexShader, pointFragmentShader);
			if (meshShader == null)
				meshShader = createShader(gl, meshVertexShader, meshFragmentShader);

			// grid

			if (gridVertBuffer == null) {

				var f = scene.fluid;
				gridVertBuffer = gl.createBuffer();
				var cellCenters = new Float32Array(2 * f.fNumCells);
				var p = 0;

				for (var i = 0; i < f.fNumX; i++) {
					for (var j = 0; j < f.fNumY; j++) {
						cellCenters[p++] = (i + 0.5) * f.h;
						cellCenters[p++] = (j + 0.5) * f.h;
					}
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, gridVertBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, cellCenters, gl.DYNAMIC_DRAW);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);
			}

			if (gridColorBuffer == null)
				gridColorBuffer = gl.createBuffer();

			if (scene.showGrid) {

				var pointSize = 0.9 * scene.fluid.h / simWidth * canvas.width;

				gl.useProgram(pointShader);
				gl.uniform2f(gl.getUniformLocation(pointShader, 'domainSize'), simWidth, simHeight);
				gl.uniform1f(gl.getUniformLocation(pointShader, 'pointSize'), pointSize);
				gl.uniform1f(gl.getUniformLocation(pointShader, 'drawDisk'), 0.0);

				gl.bindBuffer(gl.ARRAY_BUFFER, gridVertBuffer);
				var posLoc = gl.getAttribLocation(pointShader, 'attrPosition');
				gl.enableVertexAttribArray(posLoc);
				gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, gridColorBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, scene.fluid.cellColor, gl.DYNAMIC_DRAW);

				var colorLoc = gl.getAttribLocation(pointShader, 'attrColor');
				gl.enableVertexAttribArray(colorLoc);
				gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

				gl.drawArrays(gl.POINTS, 0, scene.fluid.fNumCells);

				gl.disableVertexAttribArray(posLoc);
				gl.disableVertexAttribArray(colorLoc);

				gl.bindBuffer(gl.ARRAY_BUFFER, null);
			}

			// water

			if (scene.showParticles) {
				gl.clear(gl.DEPTH_BUFFER_BIT);

				var pointSize = 2.0 * scene.fluid.particleRadius / simWidth * canvas.width;

				gl.useProgram(pointShader);
				gl.uniform2f(gl.getUniformLocation(pointShader, 'domainSize'), simWidth, simHeight);
				gl.uniform1f(gl.getUniformLocation(pointShader, 'pointSize'), pointSize);
				gl.uniform1f(gl.getUniformLocation(pointShader, 'drawDisk'), 1.0);

				if (pointVertexBuffer == null)
					pointVertexBuffer = gl.createBuffer();
				if (pointColorBuffer == null)
					pointColorBuffer = gl.createBuffer();

				gl.bindBuffer(gl.ARRAY_BUFFER, pointVertexBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, scene.fluid.particlePos, gl.DYNAMIC_DRAW);

				var posLoc = gl.getAttribLocation(pointShader, 'attrPosition');
				gl.enableVertexAttribArray(posLoc);
				gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, pointColorBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, scene.fluid.particleColor, gl.DYNAMIC_DRAW);

				var colorLoc = gl.getAttribLocation(pointShader, 'attrColor');
				gl.enableVertexAttribArray(colorLoc);
				gl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);

				gl.drawArrays(gl.POINTS, 0, scene.fluid.numParticles);

				gl.disableVertexAttribArray(posLoc);
				gl.disableVertexAttribArray(colorLoc);

				gl.bindBuffer(gl.ARRAY_BUFFER, null);
			}

			// disk

			// prepare disk mesh

			var numSegs = 50;

			if (diskVertBuffer == null) {

				diskVertBuffer = gl.createBuffer();
				var dphi = 2.0 * Math.PI / numSegs;
				var diskVerts = new Float32Array(2 * numSegs + 2);
				var p = 0;
				diskVerts[p++] = 0.0;
				diskVerts[p++] = 0.0;
				for (var i = 0; i < numSegs; i++) {
					diskVerts[p++] = Math.cos(i * dphi);
					diskVerts[p++] = Math.sin(i * dphi);
				}
				gl.bindBuffer(gl.ARRAY_BUFFER, diskVertBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, diskVerts, gl.DYNAMIC_DRAW);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);

				diskIdBuffer = gl.createBuffer();
				var diskIds = new Uint16Array(3 * numSegs);
				p = 0;
				for (var i = 0; i < numSegs; i++) {
					diskIds[p++] = 0;
					diskIds[p++] = 1 + i;
					diskIds[p++] = 1 + (i + 1) % numSegs;
				}

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diskIdBuffer);
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, diskIds, gl.DYNAMIC_DRAW);
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
			}

			if (scene.showObstacle) { // Only draw if showObstacle is true
				gl.clear(gl.DEPTH_BUFFER_BIT);

				var diskColor = [1.0, 0.0, 0.0];

				gl.useProgram(meshShader);
				gl.uniform2f(gl.getUniformLocation(meshShader, 'domainSize'), simWidth, simHeight);
				gl.uniform3f(gl.getUniformLocation(meshShader, 'color'), diskColor[0], diskColor[1], diskColor[2]);
				gl.uniform2f(gl.getUniformLocation(meshShader, 'translation'), scene.obstacleX, scene.obstacleY);
				// Add particle radius to obstacle radius for visual representation matching collision boundary
				gl.uniform1f(gl.getUniformLocation(meshShader, 'scale'), scene.obstacleRadius + scene.fluid.particleRadius);

				posLoc = gl.getAttribLocation(meshShader, 'attrPosition');
				gl.enableVertexAttribArray(posLoc);
				gl.bindBuffer(gl.ARRAY_BUFFER, diskVertBuffer);
				gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, diskIdBuffer);
				gl.drawElements(gl.TRIANGLES, 3 * numSegs, gl.UNSIGNED_SHORT, 0);

				gl.disableVertexAttribArray(posLoc);
			}

		}


		// File: 18-flip-circle.html

		function setObstacle(x, y, reset) { // x, y are center of draggable obstacle
			var vx = 0.0;
			var vy = 0.0;

			if (!reset) {
				vx = (x - scene.obstacleX) / scene.dt;
				vy = (y - scene.obstacleY) / scene.dt;
			}

			scene.obstacleX = x;
			scene.obstacleY = y;
			var rObstacle = scene.obstacleRadius; // Draggable obstacle radius
			var rObstacle2 = rObstacle * rObstacle;
			var f = scene.fluid;
			var n = f.fNumY;

			// Main circular boundary parameters from scene object
			var mainCircleX = scene.circleCenterX;
			var mainCircleY = scene.circleCenterY;
			var mainCircleR2 = scene.circleRadius * scene.circleRadius;

			for (var i = 0; i < f.fNumX; i++) { // Iterate over all grid cells
				for (var j = 0; j < f.fNumY; j++) {
					var cellRealX = (i + 0.5) * f.h;
					var cellRealY = (j + 0.5) * f.h;
					var idx = i * n + j;

					               if (f.cellType[idx] === TIME_CELL) {
					                   f.s[idx] = 0.0; // Time cells are always solid
					                   continue; // Skip further logic for this cell, preserving its TIME_CELL type
					               }

					// Check if cell is part of the main circular wall
					var distSqToMainCenter = (cellRealX - mainCircleX) * (cellRealX - mainCircleX) +
						(cellRealY - mainCircleY) * (cellRealY - mainCircleY);

					if (distSqToMainCenter > mainCircleR2) {
						f.s[idx] = 0.0; // Solid (part of main circular wall)
					                   // cellType will be set to SOLID_CELL by transferVelocities if not already TIME_CELL
					} else {
						// Cell is INSIDE the main circular boundary.
						// Default to fluid/air unless it's part of the draggable obstacle.
						f.s[idx] = 1.0;
					                   // cellType will be set to AIR_CELL (then maybe FLUID_CELL) by transferVelocities

						if (scene.showObstacle) { // Check if draggable obstacle is active
							var dxDraggable = cellRealX - x; // x,y are draggable obstacle's current center
							var dyDraggable = cellRealY - y;

							if (dxDraggable * dxDraggable + dyDraggable * dyDraggable < rObstacle2) {
								f.s[idx] = 0.0; // Mark as part of draggable obstacle
					                           // cellType will be set to SOLID_CELL by transferVelocities

								// Stamp draggable obstacle velocity onto grid cells it occupies
								// u-velocity at left face of cell (i,j) is u[i*n+j]
								// v-velocity at bottom face of cell (i,j) is v[i*n+j]
								if (i < f.fNumX) f.u[idx] = vx;                     // u at (i, j+0.5)
								if (i + 1 < f.fNumX) f.u[(i + 1) * n + j] = vx;     // u at (i+1, j+0.5) -> right face of cell (i,j)
								if (j < f.fNumY) f.v[idx] = vy;                     // v at (i+0.5, j)
								if (j + 1 < f.fNumY) f.v[i * n + (j + 1)] = vy;     // v at (i+0.5, j+1) -> top face of cell (i,j)
							}
						}
					}
				}
			}
			// scene.showObstacle is managed by mouse down/up.
			// If called with reset=true, mouse is not down, so showObstacle should be false unless explicitly set.
			// If called from drag, showObstacle is true.

			scene.obstacleVelX = vx;
			scene.obstacleVelY = vy;
		}
		// interaction -------------------------------------------------------

		var mouseDown = false;
		var isDeviceMotionEnabled = false; // Flag for sensor status

		function startDrag(x, y) {
			let bounds = canvas.getBoundingClientRect();

			let mx = x - bounds.left - canvas.clientLeft;
			let my = y - bounds.top - canvas.clientTop;
			mouseDown = true;
			scene.showObstacle = true; // Make sure the draggable obstacle is active

			x = mx / cScale;
			y = (canvas.height - my) / cScale;

			setObstacle(x, y, true);
			// scene.paused = false; // Don't unpause automatically on drag if sensors active
		}

		function drag(x, y) {
			if (mouseDown) {
				let bounds = canvas.getBoundingClientRect();
				let mx = x - bounds.left - canvas.clientLeft;
				let my = y - bounds.top - canvas.clientTop;
				x = mx / cScale;
				y = (canvas.height - my) / cScale;
				setObstacle(x, y, false);
			}
		}

		// File: 18-flip-circle.html

		function endDrag() {
			if (mouseDown) {
				mouseDown = false;
				scene.obstacleVelX = 0.0;
				scene.obstacleVelY = 0.0;
				scene.showObstacle = false; // Draggable obstacle is no longer active/visible

				var f = scene.fluid;
				var n = f.fNumY;
				var mainCircleX = scene.circleCenterX;
				var mainCircleY = scene.circleCenterY;
				var mainCircleR2 = scene.circleRadius * scene.circleRadius;

				// Reset the grid: cells inside the main circle are fluid/air (1.0),
				// cells outside are solid (0.0). This removes the draggable obstacle's footprint.
				for (var i = 0; i < f.fNumX; i++) {
					for (var j = 0; j < f.fNumY; j++) {
						var cellRealX = (i + 0.5) * f.h;
						var cellRealY = (j + 0.5) * f.h;
						var idx = i * n + j;

						                  if (f.cellType[idx] === TIME_CELL) {
						                      f.s[idx] = 0.0; // Keep time cells solid
						                      // cellType remains TIME_CELL
						                      continue;
						                  }

						var distSqToMainCenter = (cellRealX - mainCircleX) * (cellRealX - mainCircleX) +
							(cellRealY - mainCircleY) * (cellRealY - mainCircleY);

						if (distSqToMainCenter > mainCircleR2) {
							f.s[idx] = 0.0; // Solid (part of main circular wall)
						                      // transferVelocities will set cellType to SOLID_CELL
						} else {
							f.s[idx] = 1.0; // Fluid/Air (inside main circle)
						                      // transferVelocities will set cellType to AIR_CELL (or FLUID_CELL)
						}
						// Velocities for grid cells that become fluid don't need explicit reset here;
						// they will be determined by particle transfer or solver.
						// Velocities for solid wall cells will be handled by "restore solid cell velocities".
					}
				}
			}
		}
		canvas.addEventListener('mousedown', event => {
			startDrag(event.x, event.y);
		});

		canvas.addEventListener('mouseup', event => {
			endDrag();
		});

		canvas.addEventListener('mousemove', event => {
			drag(event.x, event.y);
		});

		canvas.addEventListener('touchstart', event => {
			event.preventDefault(); // Prevent scrolling/zooming
			startDrag(event.touches[0].clientX, event.touches[0].clientY)
		}, { passive: false }); // Need passive: false to preventDefault

		canvas.addEventListener('touchend', event => {
			event.preventDefault();
			endDrag()
		}, { passive: false });

		canvas.addEventListener('touchmove', event => {
			event.preventDefault(); // Prevent scrolling/zooming during drag
			event.stopImmediatePropagation();
			drag(event.touches[0].clientX, event.touches[0].clientY)
		}, { passive: false }); // Need passive: false to preventDefault


		document.addEventListener('keydown', event => {
			switch (event.key) {
				case 'p': scene.paused = !scene.paused; break;
				case 'm': scene.paused = false; simulate(); scene.paused = true; break;
			}
		});

		// *** ADDED: Device Motion Handling ***

		function handleMotion(event) {
			if (event.accelerationIncludingGravity && event.accelerationIncludingGravity.x !== null) {
				isDeviceMotionEnabled = true; // Mark sensors as active
				// Map device axes to simulation gravity
				// Assuming portrait mode:
				// event.accelerationIncludingGravity.x -> simulation X gravity
				// event.accelerationIncludingGravity.y -> simulation Y gravity (negated maybe?)
				// Need to experiment for correct mapping!

				// Common mapping: Tilting phone right increases event.x -> positive sim gravity X
				// Invert mapping: Tilting phone right increases event.x -> NEGATIVE sim gravity X (pushes fluid right)
				scene.gravityX = -event.accelerationIncludingGravity.x; // <-- Added a minus sign

				// Common mapping: Tilting phone top down increases event.y -> negative sim gravity Y
				scene.gravityY = -event.accelerationIncludingGravity.y;

				// Optional: Apply a scaling factor if tilt feels too sensitive/insensitive
				// const tiltScale = 1.0;
				// scene.gravityX *= tiltScale;
				// scene.gravityY *= tiltScale;

				// If paused, unpause when motion detected (optional)
				if (scene.paused) {
					// scene.paused = false;
				}

			} else {
				console.log("Device motion event does not contain expected data.");
				// Fallback to default gravity if sensors stop working
				scene.gravityX = 0.0;
				scene.gravityY = -9.81;
				isDeviceMotionEnabled = false;
			}
		}

		// *** ADDED: Permission Request Logic (Primarily for iOS >= 13) ***
		function requestMotionPermission() {
			if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
				// iOS 13+ specific permission request
				DeviceMotionEvent.requestPermission()
					.then(permissionState => {
						if (permissionState === 'granted') {
							window.addEventListener('devicemotion', handleMotion);
							console.log("Device motion permission granted.");
							document.getElementById('permissionButton').style.display = 'none'; // Hide button
							scene.paused = false; // Start simulation after permission
						} else {
							console.log("Device motion permission denied.");
							alert("Motion controls require permission. Please enable it in your browser settings if you change your mind.");
							document.getElementById('permissionButton').style.display = 'block'; // Keep button visible
						}
					})
					.catch(error => {
						console.error("Error requesting motion permission:", error);
						alert("Could not request motion permission. Sensors might not be available or supported.");
						document.getElementById('permissionButton').style.display = 'none'; // Hide button on error too
					});
			} else {
				// For Android and older iOS, permission is implicit or not required via this API
				// Just try adding the listener directly
				window.addEventListener('devicemotion', handleMotion);
				console.log("Attempting to add devicemotion listener (non-iOS 13+ or permission already granted).");
				// Check shortly after if events are firing
				setTimeout(() => {
					if (!isDeviceMotionEnabled) {
						console.log("Device motion events not detected after setup. Sensors might be unavailable/disabled.");
						// Keep default gravity, maybe show a message?
					} else {
						scene.paused = false; // Start if sensors seem active
					}
				}, 1000); // Wait 1 second

				// Hide the button since it's not needed for the request flow
				document.getElementById('permissionButton').style.display = 'none';
			}
		}

		// Show permission button only if the API exists (likely iOS 13+)
		if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
			// Check current permission state if possible (though this is often unreliable)
			// Instead, just show the button and let the user click it.
			document.getElementById('permissionButton').style.display = 'block';
			document.getElementById('permissionButton').onclick = requestMotionPermission;
			scene.paused = true; // Start paused until permission is granted
		} else {
			// For other platforms, attempt to start automatically
			requestMotionPermission(); // Will directly add listener
		}


		function toggleStart() {
			// This button is less relevant now, could be removed or adapted
			// var button = document.getElementById('startButton'); // Assumes button exists
			// if (button) {
			//     if (scene.paused)
			//         button.innerHTML = "Stop";
			//     else
			//         button.innerHTML = "Start";
			// }
			scene.paused = !scene.paused;
		}

		// main -------------------------------------------------------

		// *** MODIFIED main simulate function ***
		function simulate() {
			if (!scene.paused && scene.fluid) { // Check if fluid exists
				scene.fluid.simulate(
					scene.dt,
					scene.gravityX, // Pass Gx
					scene.gravityY, // Pass Gy
					scene.flipRatio, scene.numPressureIters, scene.numParticleIters,
					scene.overRelaxation, scene.compensateDrift, scene.separateParticles,
					scene.obstacleX, scene.obstacleY, scene.obstacleRadius); // Removed colorFieldNr argument
				scene.frameNr++;
			}
		}

		function update() {
		          var now = new Date();
		          var currentMinute = now.getMinutes();
		          var currentSecond = now.getSeconds();

		          if (scene.fluid && currentMinute !== scene.lastMinuteDisplayed && currentSecond === 0) {
		               // console.log("Updating time display: " + now.toLocaleTimeString());
		              updateTimeDisplayOnGrid();
		              scene.lastMinuteDisplayed = currentMinute;
		          }

			simulate();
			draw();
			requestAnimationFrame(update);
		}

		setupScene();
		      scene.lastMinuteDisplayed = new Date().getMinutes(); // Initialize for first update check
		update(); // Start the animation loop

	</script>
</body>

</html>